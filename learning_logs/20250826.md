# 입실 체크 해주세요 !! 💌
# window + e -> 여러분영어이름폴더 -> shift + 우클릭 -> Code로 열기
# 좌측 하단 프로필 클릭 -> 깃허브 로그인

# color / image 웹페이지 꾸미기
## 배경 꾸미기
### 배경에 그라데이션 넣기
- 그라데이션 : 두 가지 이상의 색을 이용하여 두 색을 점점 변화시켜 가며 채색하는 방식.(웹 사이트에서 흔히 사용되지는 않음)

https://showcases.yalco.kr/html-css/02-08/02.html
1. background 속성의 속성 값으로 linear-gradient(색1, 색2)
2. linear-gradient(각도(deg), 색1, 색2)
  - 참고 : deg -> degree
3. linear-gradient(각도, 색1, 퍼센트값, 색2)
  - 이전까지는 색상이 반반씩 나왔는데, 첫 번째 색의 구간을 지정하는 방식으로 퍼센트값을 넣어줍니다.
4. linear-gradient(색1, 색2, 색3)
- 참고 : linear-gradient(색1 퍼센트값1, 색2 퍼센트값2, 색3 퍼센트값3); 

11_gradient.html / 11_gradient.css 생성

## 포지셔닝
HTML로 작성한 문서(웹 페이지)는 하나의 기기로만 여는 것이 아니기 때문에 상대적입니다. 따라서 요소의 위치를 잡는 데 포지셔닝이 매우 중요한 역할을 합니다. 그것의 기초가 저희가 금요일에 배웠던 `<span>`과 `<div>`의 성격 차이였습니다. 그리고 어제 display: inline / block / inline-block을 배웠었습니다. 
### position 속성
참조
https://showcases.yalco.kr/html-css/02-09/01.html

12_position.html / 12_position.css 생성

- 특정 HTML 요소들이 해당 페이지에서 어떻게 배치될지를 설정하는 데 사용.
- `position 속성은 부모 요소의 것이지 자식에게 대물림되지 않음.` -> yellow의 position 속성이 red로 이어지지 않음을 뜻합니다.

1. static
  - position 속성의 default 값으로 top / left 등의 위치 조정을 하더라도 위치 이동 x -> HTML 구조를 따르는 것.
2. relative
  - 상대적인, 이라는 의미로 위치 이동이 가능.
  - 자신의 HTML 구조 상에서의 위치에서 이동하게 됩니다.
  - 해당 요소의 위치가 이동하지만 요소가 차지하는 공백은 그대로 유지가 됨.
    -> 그 결과 가장 상위 div의 범위를 아예 벗어난다고 하더라도 6번 div가 5 번 자리로 이동하지 않음

3. absolute
  - 절대적인, 이라는 의미로 `첫 부모 요소(static이 아닌 상태로 만나는 상위 HTML 구조)`의 속성값을 이용하여 위치 이동이 가능(relative랑 다른 좌표가 필요하겠네요)
  - 이상의 경우는 또 relative와 달리 공백 요소를 고정하지 않고 첫 부모의 좌표를 따라서 움직이기 때문에 공백이 생기게 될 경우 다음 div(여기서는 6번)이 위치 이동을 하는 것을 볼 수 있습니다. 위치 이동이 일어나는 이유는 display: inline-block 때문이겠죠.
  - 그래서 .yellow가 static인 상태로 .red를 postion: absolute; top: 100px; left: 100px;로 잡을 경우 .yellow가 `첫 부모가 아니기 때문에` 그 상위인 .outer가 첫 부모 요소가 되고, 때문에 회색 borderline을 가진 div 기준으로 아래로 100px, 오른쪽으로 100px 이동한 위치가 됩니다.
  - .yellow의 position을 relative로 잡게 되면 첫 부모 요소가 되기 때문에 노란색 div 기준으로 아래쪽으로 100px, 오른쪽으로 100px 이동한 위치로 .red가 이동하게 됩니다.

4. fixed
  - 고정된, 이라는 의미로, 부모 요소가 아니라 뷰포트viewport를 기준으로 위치를 지정함. 그래서 .outer보다 더 위에 있는 브라우저 흰색 부분을 기준으로 하기 때문에 똑같이 .red를 top: 100px; left: 100px;을 적용하더라도 위치가 약간 위/왼쪽으로 이동하는겁니다.
  - 뷰포트에 '고정된' 위치를 사용하기 때문에 브라우저의 스크롤링에 영향을 받지 않습니다.
    - 해당 속성을 사용하게 될 경우, 특정 팝업창을 띄웠을 때 스크롤과 상관없이 한 곳에 고정시킬 때 자주 사용하는 속성입니다.

5. sticky
  - 특정 요소가 스크롤로 이동할 수 있는 공간을 top / bottom / left / right / z-index 속성값을 이용하여 지정 가능함.
  - 예를 들어 홈페이지에서 nav에 해당하는 부분이 일정 수준까지는 아래로 스크롤링했을 때 따라 내려오는데, 그 부분을 지나게 되면 따라오지 않는 등의 효과를 줄 때 사용함.

  - 부모 요소의 여백에 영향을 받음. 자식 요소의 위치를 고정하더라도 스크롤하면서 부모 요소의 위치를 벗어난다면, 자식 요소는 그 이상 움직이지 못함. 이상을 이유로 sticky는 부모 요소의 안쪽이 아니라 동등 / 바깥쪽 요소에 지정하는 것이 좋습니다.

### z-index 속성

https://showcases.yalco.kr/html-css/02-09/02.html

- static이 아닌 모든 경우에 각 요소들간에 높이 차이를 주게 됨으로써 요소들간의 배치를 효율적으로 하기 위한 값
- 겹쳐지는 순서를 인위적으로 바꾸고자 할 때 사용함.
- z-index의 default 값은 auto로 설정되어있는데, 이는 0을 의미함.
- 0보다 큰 값을 지니고 있다면 상위로 올라가게 됨.
- 이상을 이유로 광고창 등의 경우 무조건 상위에 있어야하기 때문에 css 파일 확인해보시면 z-index: 999; 같은 것도 구경할 수 있습니다.

13_zindex.html / 13_zindex.css 생성

## flex 레이아웃
- 모든 웹사이트는 큰 레이아웃 형태의 구조로 되어있고, 이 레이아웃을 만드는 방법은 다양합니다. 예전에는 HTML 테이블 구조와 블록/인라인의 조합으로 사이트 구조를 만들어야 했는데, 오늘날 flex가 나오면서 각종 CSS 기능을 통해 레이아웃을 설정하게 되었습니다.

### 부모에 적용하는 flex
참조
https://showcases.yalco.kr/html-css/02-11/01.html

- 참고 : 부모에 적용하는 속성이라는 것은 부모 관련 css에 작성한다는 뜻으로 사용합니다.

참조 사이트를 기준으로 바깥쪽 div에 display: flex;를 적용했을 때와 display: inline-flex;를 적용했을 때의 p 태그 위치가 바뀌는 점을 확인할 수 있습니다.

이상의 차이에서 확인할 수 있는 점 :
  1. display: flex;를 div에 적용했을 경우 block 성질은 그대로 유지된 상태로 flex가 적용됨
  - 그래서 p 태그가 개행된 상태로 출력
  2. display: inline-flex;를 div에 적용했을 경우 block 성질이 inline으로 바뀌게 되면서 회색 div 영역 이후의 부분에 p 태그의 텍스트가 출력됨.

1. flex-direction 속성
  - 내부의 자식 요소들을 어느 축을 기준으로 정렬할지 결정.
  - default 값은 row(왼쪽부터 차례대로 정렬함) -> 자식 요소들을 row로 정렬하기 때문에 참조 사이트 기준 1, 2, 3 div가 세로로 길게 출력됨.

2. justify-content
  - 메인 축에서 내부 요소를 정렬하는 방식을 결정.
  - default 값은 flex-start : 왼쪽부터 내부 요소 정렬
  - center : 텍스트 중앙 정렬한 것처럼 내부 요소들을 중앙에 배치함.
  - flex-end : 메인 축의 끝 부분인 오른쪽으로 내부 요소가 정렬됨. 순서는 flex-direction을 따릅니다.
  - space-between : 맨 왼쪽과 오른쪽에 하나씩 배치하고 그 사이에 나머지 요소들을 균등하게 배치
  - space-around : 각 내부 요소의 양쪽에 일정한 크기의 빈 공간을 배치. -> 1번 div 좌우에 margin처럼 보이는 애가 있고, 2번 div의 좌우에 margin이 있는 것처럼 보여서 중간 부분만 뻥 비어보입니다.
  - space-evenly : 모든 빈 공간의 크기를 고르게 지정

3. align-items : flex의 메인 축에서의 반대편 축에서(즉 flex-direction: row;라면 y축 방향으로, flex-direction: column;이라면 x축 방향으로) 내부 요소를 정렬할 방식을 결정함.
  - () 내부의 내용을 토대로 flex-direction: row;라면 반대 방향인 세로 방향으로 stretch가 일어나서 세로로 긴 div이 3 개 생겼다고 볼 수 있겠습니다.
  - stretch : align-items의 default값으로 이상의 설명처럼 길게 늘립니다.
  - flex-start : min-width / min-height의 크기 그대로 정렬하는 위치를 왼쪽 상단으로부터 시작함.
  - center : 중앙 정렬
  - flex-end : 수직 축의 끝 부분인 아래로 정렬

- 참고 : display:flex / flex-direction / align-items는 대부분 세트로 같이 돌아다니기 때문에 이 사이트에서 이리저리 움직여보고 css 값을 넣어보는 것도 좋은 방법입니다.

4. flex-wrap
  - 내부 요소들이 자식 요소의 영역을 넘어가는 부분을 전제로 배치 방식을 자동으로 바꿔주는 속성값
  - default 값 : no-wrap
  - wrap으로 설정하게 되면 내부 요소가 부모 요소를 넘어가지 않도록 줄바꿈이 일어남. 주로 컨텐츠가 한 줄이 아니라 여러 줄일 때 사용
  - 페이지 상에서의 효과를 보면 min-width / min-height를 가지고 있는 상태에서 최대한 stretch가 적용되어 부모 div의 영역을 차지하는 것을 확인할 수 있습니다. 만약에 그게 보기 싫으면 stretch를 flex-start / center / flex-end로 바꾸면 되죠.

5. align-content
  - align-items와 혼동이 일어나기 쉽습니다. align-items의 경우에는 flex-start / center / flex-end를 적용했을 경우 가운데 여백이 같은 크기의 공백으로 나뉘어진 상태에서 내부 요소가 위 / 중간 / 아래에서 정렬이 일어납니다. 그래서 첫째줄과 둘째줄 사이에 공백이 있습니다.

  - 반면 align-content를 사용했을 경우 1번 ~ 12번 div이 하나의 묶으로 공백없이 정렬된 상태에서 위 / 중간 / 아래에 정렬이 일어납니다.

6. gap - 내부 요소들 사이에 들어가는 공백의 크기를 지정(그러니까 자식 div에 margin 적용하는거랑 혼동하기가 쉽습니다).

### 자식에 적용하는 flex

1. flex-basis / flex-shrink
  - 자식에 flex 관련 속성을 사용하기 위해서는 부모의 css에 disply: flex;가 적용되어있어야 합니다. 그리고 아까 위에서 말한 것처럼 세트인 flex-direction을 적용해야 합니다. 이제 설명하는 부분은 flex-direction: row;를 기준으로 합니다.

  - `부모 요소에서 flex-direction: row;`이므로 자식 요소에서의 flex-basis는 row 방향으로의 크기를 지정합니다.
  - default 값은 auto;
  - 절대값 / 상대값을 적용할 수 있습니다.

  - 만약에 자식 요소의 flex-basis를 절대값으로 잡는 바람에 부모 요소의 크기를 거기에 맞춰서 강제로 증가시키게 된다면 반응형 페이지라고 할 수 없을 겁니다.
  - 해당 경우에 사용하는 것이 flex-shrink입니다.
  - default 값 : 1
    - 전체 공간이 부족할 경우 해당 내부 요소의 크기가 컨텐츠(여기서는 주황색 div)의 width 또는 flex-basis의 최대 크기가 부모 요소를 넘어가지 못하도록 강제하는 값

2. flex-grow
  - default 값 : 0 - 기존의 크기를 그대로 유지함
  - 숫자의 크기에 따라 나머지 형제 요소들의 공백 크기의 곱만큼 자기가 커집니다.(커지는 방향은 부모의 flex-direction 설정값에 따름).

## 요소를 감추는 방법
1. 원래 보이던 요소를 투명하게 만드는 방법
2. 요소가 보이지 않으면서 가지고 있는 기능 자체도 날리는 방법

### CSS에서 요소를 숨기는 세 가지 방법
1. opacity 속성 활용
  - 불투명도를 뜻하며 범위는 0 ~ 1 사이의 값. 0으로 하면 불투명도 0이기 때문에 투명해집니다.
  - 해당 요소를 투명하게 만드는 것이기 때문에 기능은 존재합니다.
  - 예전에 악성 광고 사이트 같은데서 많이 쓰던 방법인데 광고팝업을 opacity: 0;로 설정해서 클릭하면 광고 페이지로 넘어가게 하는 방식이었습니다.
2. visibility 속성 활용
  - visibility의 속성값 : visible / hidden 두 가지로, hidden을 경우에 숨겨짐
  - 기능도 사라집니다.
  - 그런데 공백은 남아있어요. 보이냐 안보이냐만 지정했기 때문에 그냥 안보이는 상태에서 기능해제까지 도입되었다고 볼 수 있겠습니다.
3. display 속성 활용
  - 얘는 많은 속성값이 있었습니다. 저희가 배운 것만 해도
  - flex
  - block
  - inline
  - inline-block
  - 그런데 참조 사이트에는 div 들이 일렬로 나열돼야 하기 때문에 inline-block만 나와있었습니다.
  - 그리고 none을 쓰게 되면
    - 눈에 안보이고 / 기능 삭제 되고 / 아예 없는게 되기 때문에 뒤에 있던 div가 앞으로 밀려오는 것까지 확인할 수 있습니다.

참조
https://showcases.yalco.kr/html-css/02-10/02.html


식사 후에

# CSS 고급 기능(이지만 최근에는 필수인)
## 반복 및 공통되는 스타일
## 벤더 프리픽스

# 서체 스타일링
## 서체 및 웹 폰트(필수 / 구글 폰트 및 눈누 폰트 때문에)